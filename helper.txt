Plano passo a passo (alto-n√≠vel)

    L√™ e entenda o enunciado

        Confirma par√¢metros esperados (infile cmd1 cmd2 outfile) e se h√° here_doc/bonus.

        Decide comportamento em erros (mensagem, exit code) seguindo o enunciado da 42.

    Configura o projeto

        Cria Makefile (flags -Wall -Wextra -Werror) e estrutura (src/, includes/).

        Coloca #include e prot√≥tipos num header comum.

    Implementa utilit√°rios m√≠nimos

        Fun√ß√µes para: alocar e libertar matrizes de strings, duplicar strings, tratar erros com perror e exit.

        Testa essas fun√ß√µes isoladamente.

    Parsing dos argumentos

        Valida n√∫mero de argumentos.

        Detecta modo normal vs here_doc (se aplic√°vel).

        Extrai as strings de comando (ex.: "ls -l").

    Abrir ficheiros de entrada/sa√≠da

        open(infile, O_RDONLY) para entrada.

        open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0644) (ou append para here_doc).

        Tratar erros (ENOENT, EACCES, EISDIR) retornando a mensagem e o exit code conforme as regras.

    Resolver comando para exec

        Entender execve espera um char *path e char *const argv[].

        Se o comando j√° √© um caminho absoluto/relativo (/bin/ls ou ./meuprog) usar direto.

        Sen√£o, obter PATH do ambiente, dividir por : e procurar execut√°vel em cada diret√≥rio.

        Testar com access(path, X_OK) antes de chamar execve.

        Se n√£o achar, tratar como comando inexistente.

    Montar pipeline b√°sico (2 comandos inicialmente)

        Cria um pipe().

        fork() o primeiro filho:

            redireciona stdin para infile e stdout para o write end do pipe (dup2).

            fecha descritores n√£o usados.

            execve do comando1.

        fork() o segundo filho:

            redireciona stdin para read end do pipe e stdout para outfile.

            fecha descritores n√£o usados.

            execve do comando2.

        No pai:

            fecha ambos ends do pipe e infile/outfile se n√£o precisar.

            waitpid para os filhos e recolhe status de sa√≠da.

    Generalizar para N comandos (bonus obrigat√≥rio em muitos testes)

        Para cada comando extra, cria um pipe novo e encadeia:

            Cada processo tem stdin vindo do pipe anterior (ou infile no primeiro) e stdout indo para o pr√≥ximo pipe (ou outfile no √∫ltimo).

        Garante fechar ends que n√£o s√£o necess√°rios ‚Äî cuidado: esquecer de fechar ends causa hang.

    Tratar sinais, c√≥digos de sa√≠da e wait

        Usa waitpid para cada filho e pega o status com macros (WIFEXITED, WEXITSTATUS).

        Decide que c√≥digo o pipex deve retornar (especifica√ß√£o do projeto normalmente diz qual filho define o exit code).

    Libertar recursos

        Fecha todos os descritores.

        Liberta memoria alocada (matrizes, strings).

        Evita memory leaks (testa com Valgrind).
        
Functions used

You are allowed to use several functions in this project. You already know some of them like write, ft_printf, malloc, free and all the functions from your libft. However, other important functions that have never been used before will be essential to the success of this project. Let's look at them together.
access()

int access(const char *pathname, int mode);

access() checks whether the program can access the file pathname. 

The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK. F_OK tests for the existence of the file. R_OK, W_OK, and X_OK test whether the file exists and grants read, write, and execute permissions, respectively.

On success (all requested permissions granted), zero is returned. On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned, and errno is set appropriately.

You can find more information on access() here: https://linux.die.net/man/2/access
dup2()

int dup2(int oldfd, int newfd);

dup2() makes newfd be the copy of oldfd, closing newfd first if necessary, but note the following:

    If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.

    If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.

After a successful return from dup2(), the old and new file descriptor may be used interchangeably. They refer to the same open file description and thus share file offset and file status flags; for example, if the file offset is modified by using lseek() on one of the descriptors, the offset is also changed for the other.

On error, the dup2() function returns -1.

You can find more information on dup2() here: https://linux.die.net/man/2/dup2
pipe()

int pipe(int pipefd[2]);

pipe() creates a pipe, a unidirectional data channel that can be used for interprocess communication. The array pipefd is used to return two file descriptors referring to the ends of the pipe. pipefd[0] refers to the read end of the pipe. pipefd[1] refers to the write end of the pipe. Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe

On success, 0 is returned. On error, -1 is returned, and errno is set appropriately.

fork()

pid_t fork(void);

fork() creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent, except for some points that you can find here (there's too may to write them all down here).

waitpid()

pid_t waitpid(pid_t pid, int *status, int options);

The waitpid() system call suspends execution of the calling process until a child specified by pid argument has changed state. By default, waitpid() waits only for terminated children.

You can find more information about wait() and waitpid() here.
wait()

pid_t wait(int *status);

The wait() system call suspends execution of the calling process until one of its children terminates.

You can find more information about wait() and waitpid() here.
execve()

int execve(const char *filename, char *const argv[], char *const envp[]);

execve() executes the program pointed to by filename.

execve() does not return on succes, the calling process is replaced by the executed filename.

unlink()

int unlink(const char *pathname);

unlink() deletes a name from the file system. If that name was the last link to a file and no processes have the file open the file is deleted and the space it was using is made available for reuse.

If the name was the last link to a file but any processes still have the file open the file will remain in existence until the last file descriptor referring to it is closed.

On success, 0 is returned. On error, -1 is returned, and errno is set appropriately.

You can find more information about unlink() here.
Final word

The way pipes are described generally is that it redirects the output of one command to the input of the next command. That is correct. But there's a catch, when you build pipex, you have to launch a new child process for each command you want to do, and they are all made at the same time.

That means all commands are run at the same time, it's just that they will wait for the writing end of the pipe to be closed before reading from the pipe.




--------------------------------------------------------------------------------------------------------------------------------------------
FUN√á√ïES DE ERROS
1. perror

    O que faz: Imprime uma mensagem de erro no terminal com base no erro atual (errno).

    Uso comum: Para dizer ao usu√°rio o que deu errado.

perror("Erro ao abrir arquivo");

Se o erro for, por exemplo, "arquivo n√£o encontrado", a sa√≠da ser√° algo como:

Erro ao abrir arquivo: No such file or directory

2. strerror

    O que faz: Retorna uma string com a descri√ß√£o de um erro baseado no n√∫mero do erro (errno).

    Uso comum: Quando voc√™ quer salvar ou personalizar a mensagem de erro.

printf("Erro: %s\n", strerror(errno));

üîê ACESSO A ARQUIVOS
3. access

    O que faz: Verifica se um arquivo existe e se tem permiss√µes (leitura, escrita, execu√ß√£o).

    Uso comum: Antes de tentar abrir ou executar um arquivo.

if (access("arquivo.txt", F_OK) == 0)
    printf("O arquivo existe\n");

    F_OK: verifica exist√™ncia

    R_OK: leitura

    W_OK: escrita

    X_OK: execu√ß√£o

üåÄ DUPLICA√á√ÉO DE DESCRITORES
4. dup

    O que faz: Cria uma c√≥pia de um descritor de arquivo.

    Uso comum: Redirecionamento (ex: salvar a stdin original).

int stdin_copy = dup(0); // duplica STDIN (fd 0)

5. dup2

    O que faz: Mesma ideia do dup, mas voc√™ escolhe o n√∫mero do novo descritor.

    Uso comum: Para redirecionar entrada/sa√≠da.

int file = open("saida.txt", O_WRONLY);
dup2(file, 1); // redireciona stdout para o arquivo

Agora, tudo que for printf vai para "saida.txt".
üöÄ EXECU√á√ÉO DE PROCESSOS
6. execve

    O que faz: Substitui o processo atual por um novo (executa um programa).

    Uso comum: Ap√≥s o fork, o filho chama execve para rodar um comando.

char *args[] = {"/bin/ls", "-l", NULL};
execve("/bin/ls", args, environ);

    N√£o volta nunca se der certo.

    Se der erro, retorna -1.

7. exit

    O que faz: Encerra um processo com um c√≥digo de sa√≠da.

    Uso comum: Para finalizar o programa com sucesso ou erro.

exit(0);  // sucesso
exit(1);  // erro

üß¨ PROCESSOS
8. fork

    O que faz: Cria um novo processo (um "clone" do atual).

    Uso comum: Para fazer um processo filho.

pid_t pid = fork();

if (pid == 0)
    printf("Sou o filho\n");
else
    printf("Sou o pai\n");

    Retorna 0 no filho e PID do filho no pai.

9. pipe

    O que faz: Cria um canal de comunica√ß√£o entre dois processos.

    Uso comum: Para conectar a sa√≠da de um comando com a entrada de outro.

int fd[2];
pipe(fd); // fd[0] leitura, fd[1] escrita

10. unlink

    O que faz: Remove (deleta) um arquivo.

    Uso comum: Apagar arquivos tempor√°rios.

unlink("temporario.txt");

‚è≥ SINCRONIZA√á√ÉO DE PROCESSOS
11. wait

    O que faz: Espera qualquer filho terminar.

    Uso comum: O pai espera o filho.

int status;
wait(&status);

12. waitpid

    O que faz: Espera um filho espec√≠fico terminar.

    Uso comum: Quando voc√™ quer esperar s√≥ um PID.

int status;
waitpid(pid, &status, 0);

üìå Resumo Tabela R√°pida
Fun√ß√£o	Para que serve
perror	Imprime erro autom√°tico
strerror	Retorna string do erro
access	Verifica se o arquivo existe/permiss√µes
dup	Duplica descritor de arquivo
dup2	Duplica descritor para n√∫mero espec√≠fico
execve	Executa outro programa
exit	Termina o processo
fork	Cria um novo processo
pipe	Cria comunica√ß√£o entre processos
unlink	Apaga arquivo
wait	Espera um filho qualquer
waitpid	Espera um filho espec√≠fico